// ===================== Config & Pins =====================
// D2: ปุ่มนับเวลา 20 วินาทีเพื่อ "ปลดล็อก" การใช้งาน D4
// D4: ปุ่มสั่งงานรีเลย์ (ต้องกดค้าง >= 0.5 วินาที) ใช้ได้เมื่อระบบ "ปลดล็อก" แล้ว
const int buttonPin   = 2;    // D2: Arm/Unlock button
const int overridePin = 4;    // D4: Override/Relay-control button
const int ledPin      = 13;   // LED แสดงสถานะ
const int relayPin    = 8;    // รีเลย์
const int greenPin    = 3;    // D3: ไฟเขียว แสดงสถานะ "ปลดล็อกแล้ว"

// Relay active level (เปลี่ยนเป็น LOW ถ้ารีเลย์ Active LOW)
const int RELAY_ACTIVE_LEVEL   = HIGH;
const int RELAY_INACTIVE_LEVEL = (RELAY_ACTIVE_LEVEL == HIGH ? LOW : HIGH);

// Timing (ms)
const unsigned long TIMEOUT_MS       = 20000; // กด D2 ค้าง 20 วิ เพื่อ "ปลดล็อก"
const unsigned long BLINK_FAST_MS    = 500;   // กระพริบเร็วระหว่างนับ
const unsigned long BLINK_SLOW_MS    = 2000;  // กระพริบช้าเมื่อ "ปลดล็อกแล้ว" (2 วิ ตามที่ขอ)
const unsigned long OVERRIDE_HOLD_MS = 250;   // D4 ต้องกดค้างอย่างน้อย 0.25 วิ เพื่อสั่งรีเลย์

// ===================== LED State Machine =====================
enum LedMode { LED_OFF, LED_BLINK_FAST, LED_BLINK_SLOW, LED_ON };
LedMode ledMode = LED_OFF;
bool ledState = false;                 // สถานะ HIGH/LOW ที่แสดงผลจริง
unsigned long lastBlinkToggleMs = 0;   // เวลา toggle ล่าสุด

void setLedMode(LedMode m) {
  if (ledMode != m) {
    ledMode = m;
    lastBlinkToggleMs = millis(); // reset phase
    switch (ledMode) {
      case LED_OFF:
        ledState = false;
        digitalWrite(ledPin, LOW);
        break;
      case LED_ON:
        ledState = true;
        digitalWrite(ledPin, HIGH);
        break;
      case LED_BLINK_FAST:
      case LED_BLINK_SLOW:
        ledState = false; // เริ่มจากดับ
        digitalWrite(ledPin, LOW);
        break;
    }
  }
}

void updateLed() {
  unsigned long now = millis();
  if (ledMode == LED_BLINK_FAST) {
    if (now - lastBlinkToggleMs >= BLINK_FAST_MS) {
      ledState = !ledState;
      digitalWrite(ledPin, ledState ? HIGH : LOW);
      lastBlinkToggleMs = now;
    }
  } else if (ledMode == LED_BLINK_SLOW) {
    if (now - lastBlinkToggleMs >= BLINK_SLOW_MS) {
      ledState = !ledState;
      digitalWrite(ledPin, ledState ? HIGH : LOW);
      lastBlinkToggleMs = now;
    }
  }
  // LED_ON / LED_OFF ไม่ต้องทำอะไรเพิ่ม
}

// ===================== Logic State =====================
bool timing         = false;   // กำลังนับ 20 วิ จาก D2 หรือไม่
bool armed          = false;   // ปลดล็อกแล้วหรือยัง (true = ใช้ D4 ได้)
bool overrideActive = false;   // รีเลย์ ON อยู่เพราะ D4 หรือไม่

// กด D4 ค้างเพื่อตรวจครบ 0.5 วิ
unsigned long overridePressStartMs = 0;

// ความคืบหน้าการนับของ D2
unsigned long pressStartMs        = 0;
unsigned long lastSecondTickMs    = 0;
unsigned long elapsedSecondsShown = 0;

// ปุ่ม (อ่านทุกลูป)
bool armBtnPressed       = false; // แทน buttonPressed เดิม
bool overrideBtnPressed  = false; // แทน overridePressed เดิม
bool prevArmBtnPressed   = false; // สำหรับ edge detection

// ===================== Setup =====================
void setup() {
  pinMode(ledPin, OUTPUT);
  pinMode(buttonPin,   INPUT_PULLUP);
  pinMode(overridePin, INPUT_PULLUP);
  pinMode(relayPin, OUTPUT);
  pinMode(greenPin, OUTPUT);

  digitalWrite(relayPin, RELAY_INACTIVE_LEVEL);
  digitalWrite(greenPin, LOW); // เริ่มต้นยังไม่ปลดล็อก → ดับ
  setLedMode(LED_OFF);

  Serial.begin(115200);
  Serial.println(F("== System Ready =="));
  Serial.println(F("D2 (Arm): กดค้าง 20 วิ เพื่อ 'ปลดล็อก' ให้ D4 ใช้งานได้ (ปล่อย = RESET ระบบ)"));
  Serial.println(F("D4 (Override): ใช้ได้เมื่อปลดล็อกแล้ว กดค้าง >=0.5 วิ → รีเลย์ ON (ปล่อย = OFF)"));
  Serial.println(F("LED(13): กระพริบเร็ว=กำลังนับ, กระพริบช้า(2วิ)=ปลดล็อกแล้ว, ติดค้าง=รีเลย์ ON, ดับ=สถานะอื่น"));
  Serial.println(F("LED เขียว(D3): ติดเมื่อ 'ปลดล็อกแล้ว', ดับเมื่อรีเซ็ต/ยังไม่ปลดล็อก"));
}

// ===================== Loop =====================
void loop() {
  unsigned long now = millis();

  // อ่านสถานะปุ่ม (Active LOW → กด = LOW)
  armBtnPressed      = (digitalRead(buttonPin)   == LOW);
  overrideBtnPressed = (digitalRead(overridePin) == LOW);

  // ---------- D2: นับเวลาเพื่อปลดล็อก ----------
  // เริ่มนับ "เฉพาะตอนเปลี่ยนจากไม่กด → กด" (rising edge) และเมื่อยังไม่ armed
  bool startCountdown = (armBtnPressed && !prevArmBtnPressed && !armed && !timing);
  if (startCountdown) {
    timing = true;
    armed  = false;                 // เริ่มรอบใหม่ = รีเซ็ตการปลดล็อกเสมอ
    pressStartMs = now;
    lastSecondTickMs = now;
    elapsedSecondsShown = 0;

    digitalWrite(greenPin, LOW);    // เริ่มนับใหม่ยังไม่ปลดล็อก → ดับ D3
    Serial.println(F("[D2] เริ่มนับ 20 วินาทีเพื่อปลดล็อก"));
    setLedMode(LED_BLINK_FAST);     // กระพริบเร็วระหว่างนับ
  }

  if (armBtnPressed && timing) {
    // รายงานเวลาที่ผ่านไปเป็นวินาที
    if (now - lastSecondTickMs >= 1000) {
      elapsedSecondsShown++;
      Serial.print(F("[TIMER] ผ่านไป "));
      Serial.print(elapsedSecondsShown);
      Serial.println(F(" วินาที"));
      lastSecondTickMs += 1000;
    }

    // ครบเวลา → ปลดล็อก (armed = true) แล้ว "ไม่เริ่มรอบใหม่" จนกว่าจะปล่อยแล้วกดใหม่
    if (now - pressStartMs >= TIMEOUT_MS) {
      armed  = true;
      timing = false;
      digitalWrite(greenPin, HIGH);   // ปลดล็อกแล้ว → ไฟเขียวติด
      Serial.println(F("[D2] ครบ 20 วินาที → ปลดล็อก D4 (armed = true)"));
      if (!overrideActive) setLedMode(LED_BLINK_SLOW); // ไฟสถานะปลดล็อก (2 วิ)
    }
  }

  // ---------- RESET เมื่อ "ปล่อย" ปุ่ม Arm ----------
  if (!armBtnPressed && prevArmBtnPressed) {
    bool wasTiming = timing;
    bool wasArmed  = armed;

    // รีเซ็ตระบบทันทีเมื่อปล่อย D2
    timing = false;
    armed  = false;
    digitalWrite(greenPin, LOW);      // รีเซ็ต → ไฟเขียวดับ

    // ถ้ารีเลย์กำลัง ON อยู่จาก override ให้ปิดด้วย
    if (overrideActive) {
      Serial.println(F("[RESET] ปล่อย D2 → ปิดรีเลย์ & ออกจากโหมด override"));
      overrideActive = false;
      digitalWrite(relayPin, RELAY_INACTIVE_LEVEL);
    }

    // LED: ดับ (กลับสู่สถานะปกติ)
    setLedMode(LED_OFF);

    // ข้อความสถานะ
    if (wasTiming && !wasArmed) {
      Serial.print(F("[D2] ปล่อยก่อนครบเวลา → ยกเลิกที่ "));
      Serial.print(elapsedSecondsShown);
      Serial.println(F(" วินาที (RESET)"));
    } else if (wasArmed) {
      Serial.println(F("[D2] ปล่อยหลังปลดล็อก → RESET ระบบ (armed=false)"));
    } else {
      Serial.println(F("[D2] ปล่อย D2 → RESET ระบบ"));
    }
  }

  // ---------- D4: Override (ทำงานได้เฉพาะเมื่อ armed == true) ----------
  if (armed && overrideBtnPressed) {
    if (!overrideActive && overridePressStartMs == 0) {
      // เพิ่งเริ่มกด → เริ่มจับ 0.25 วิ กันกดพลาด
      overridePressStartMs = now;
    } else if (!overrideActive && (now - overridePressStartMs >= OVERRIDE_HOLD_MS)) {
      // กดค้างครบ 0.5 วิ → เปิดรีเลย์
      overrideActive = true;
      Serial.println(F("[OVERRIDE] กด D4 ค้างครบ 0.5 วิ → เปิดรีเลย์"));
      digitalWrite(relayPin, RELAY_ACTIVE_LEVEL);
      setLedMode(LED_ON); // รีเลย์ ON → LED ติดค้าง
    }
  } else {
    // D4 ไม่ได้กดอยู่ (หรือยังไม่ armed)
    if (overrideActive) {
      // ถ้าเดิม ON อยู่ แล้วปล่อย → ปิดรีเลย์
      Serial.println(F("[OVERRIDE] ปล่อย D4 → ปิดรีเลย์"));
      overrideActive = false;
      digitalWrite(relayPin, RELAY_INACTIVE_LEVEL);
      // หลังปล่อย: ถ้ายัง armed → กระพริบช้า, ไม่ armed → ดับ
      setLedMode(armed ? LED_BLINK_SLOW : LED_OFF);
    }
    overridePressStartMs = 0; // reset ตัวจับเวลา D4
  }

  // ---------- อัปเดต LED ตามโหมด ----------
  updateLed();

  // เก็บสถานะปุ่ม D2 สำหรับ edge detection รอบถัดไป
  prevArmBtnPressed = armBtnPressed;
}
